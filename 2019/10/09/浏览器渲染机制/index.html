
<!DOCTYPE html>
<html lang="" class="loading">
<head><meta name="generator" content="Hexo 3.8.0">
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Hexo</title>

    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="google" content="notranslate">
    <meta name="keywords" content="Fechin,"> 
    <meta name="description" content="一、Es6中的setSet 内部判断两个值是否不同，使用的算法叫做“Same-value-zero equality”，它类似于精确相等运算符（===），主要的区别是向 Set 加入值时认为NaN等,"> 
    <meta name="author" content="zxSmile"> 
    <link rel="alternative" href="atom.xml" title="Hexo" type="application/atom+xml"> 
    <link rel="icon" href="/img/favicon.png"> 
    <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">
    <link rel="stylesheet" href="/css/diaspora.css">
</head>
</html>
<body class="loading">
    <div id="loader"></div>
    <div id="single">
    <div id="top" style="display: block;">
    <div class="bar" style="width: 0;"></div>
    <a class="icon-home image-icon" href="javascript:;"></a>
    <div title="播放/暂停" class="icon-play"></div>
    <h3 class="subtitle">浏览器渲染机制</h3>
    <div class="social">
        <!--<div class="like-icon">-->
            <!--<a href="javascript:;" class="likeThis active"><span class="icon-like"></span><span class="count">76</span></a>-->
        <!--</div>-->
        <div>
            <div class="share">
                <a title="获取二维码" class="icon-scan" href="javascript:;"></a>
            </div>
            <div id="qr"></div>
        </div>
    </div>
    <div class="scrollbar"></div>
</div>
    <div class="section">
        <div class="article">
    <div class="main">
        <h1 class="title">浏览器渲染机制</h1>
        <div class="stuff">
            <span>十月 09, 2019</span>
            

        </div>
        <div class="content markdown">
            <h3 id="一、浏览器的主要组成"><a href="#一、浏览器的主要组成" class="headerlink" title="一、浏览器的主要组成"></a>一、浏览器的主要组成</h3><ul>
<li><p>用户界面－包括地址栏、后退/前进按钮、书签目录等，也就是你所看到的除了用来显示你所请求页面的主窗口之外的其他部分</p>
</li>
<li><p>浏览器引擎－用来查询及操作渲染引擎的接口</p>
</li>
<li><p>渲染引擎－用来显示请求的内容，例如，如果请求内容为html，它负责解析html及css，并将解析后的结果显示出来</p>
</li>
<li><p>网络－用来完成网络调用，例如http请求，它具有平台无关的接口，可以在不同平台上工作</p>
</li>
<li><p>UI 后端－用来绘制类似组合选择框及对话框等基本组件，具有不特定于某个平台的通用接口，底层使用操作系统的用户接口</p>
</li>
<li><p>JS解释器（又称JavaScript引擎）－用来解释执行JS代码</p>
</li>
<li><p>数据存储－属于持久层，浏览器需要在硬盘中保存类似cookie的各种数据，HTML5定义了web database技术，这是一种轻量级完整的客户端存储技术</p>
<h3 id="二、浏览器主要的功能"><a href="#二、浏览器主要的功能" class="headerlink" title="二、浏览器主要的功能"></a>二、浏览器主要的功能</h3><p>浏览器的主要功能是将用户选择的web资源呈现出来，它需要从服务器请求资源，并将其显示在浏览器窗口中，资源的格式通常是HTML，也包括PDF、image及其他格式。用户用URI来指定所请求资源的位置。</p>
<h3 id="三、从输入-URL-到页面加载完成，发生了什么？"><a href="#三、从输入-URL-到页面加载完成，发生了什么？" class="headerlink" title="三、从输入 URL 到页面加载完成，发生了什么？"></a>三、从输入 URL 到页面加载完成，发生了什么？</h3><p>DNS 解析  <br><br> |      <br><br>TCP 连接   <br><br> |<br><br>HTTP 请求抛出<br><br> |<br><br>服务端处理请求，HTTP 响应返回<br><br> |<br><br>浏览器拿到响应数据，解析响应内容，把解析的结果展示给用户<br></p>
<h3 id="四、浏览器渲染机制"><a href="#四、浏览器渲染机制" class="headerlink" title="四、浏览器渲染机制"></a>四、浏览器渲染机制</h3><p>浏览器渲染的处理就是最后一步，浏览器拿到响应数据，解析响应内容，把解析的结果展示给用户。<br><br><b>浏览器内核</b><br><br>浏览器的内核是指支持浏览器运行的最核心的程序，负责将页面转变为可视化的图像结果,分为两个部分，一是渲染引擎，另一个是JS引擎。</p>
</li>
<li>渲染引擎，负责对网页语法的解释（如HTML、JavaScript）并渲染网页。渲染引擎决定了浏览器如何显示网页的内容以及页面的格式信息。</li>
<li>JavaScript引擎的主要作用是，读取网页中的JavaScript代码，对其处理后运行。<br><b>关键渲染路径</b><br><br>关键渲染路径是指浏览器从最初接受到请求的HTML、CSS、javascript等资源，然后解析、构建树、渲染布局、绘制，最后呈现给客户能看到的界面这整个过程。用户看到页面实际上可以分为两个阶段：页面内容加载完成和页面资源完成，分别对应于DOMContentLoaded和Load。<br><br>整个关键渲染路径包括以下几个步骤：</li>
<li>解析HTML，生成DOM树（DOM）</li>
<li>解析CSS，生成CSSOM树（CSSOM）</li>
<li>将DOM和CSSOM合并，生成渲染树（Render-Tree）</li>
<li>计算渲染树的布局（Layout）</li>
<li>将布局渲染到屏幕上（Paint）<br>以上步骤没有包括脚本JS的处理，并不是脚本处理不在关键渲染路径中，而是因为JS的处理会对1、2产生影响，下面会介绍。<br>1.DOM的生成<br><br>首先我们知道，数据在网络传输中是以“数据包”的形式通过互联网发送，而数据包以字节为单位。<br><br>当你编写一些 HTML、CSS 和 JS，并试图在浏览器中打开 HTML 文件时，浏览器会从你的硬盘（或网络）中读取 HTML 的原始字节。浏览器读取的是原始数据字节，而不是你编写的代码的实际字符。但是，它用这些数据什么都做不了。数据的原始字节必须转换为它所理解的形式。<br><br>浏览器对象需要处理的是文档对象模型（DOM）对象。所以要将构建一个DOM对象：<br></li>
<li>首先，根据文件的指定编码（例如 UTF-8）将原始数据字节转换为字符,也就是我们写的代码。</li>
<li>将字符转换成Token，例如： <html>、 <body>等。Token中会标识出当前Token是“开始标签”或是“结束标签”亦或是“文本”等信息。</body></html></li>
<li>生成节点对象并构建DOM<br>事实上，构建DOM的过程中，不是等所有Token都转换完成后再去生成节点对象，而是一边生成Token一边消耗Token来生成节点对象。换句话说，每个Token被生成后，会立刻消耗这个Token创建出节点对象。<b>注意：带有结束标签标识的Token不会创建节点对象。<b><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;Web page parsing&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;h1&gt;Web page parsing&lt;/h1&gt;</span><br><span class="line">        &lt;p&gt;This is an example Web page.&lt;/p&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
</b></b></li>
</ul>
<p>上面这段HTML会解析成这样：<br><br><img src="/2019/10/09/浏览器渲染机制/img1.png" alt=""><br>解析完HTML，单纯使用DOM，浏览器并不知道如何渲染这棵树，DOM只是存储了元素的关系，并没有任何渲染信息，如宽高、颜色、背景、定位等。存储这些信息，就需要CSSOM了。<br><br><b>2.CSSOM生成</b><br><br>在HTML的解析过程中，会碰到style、link和内联样式，这时，浏览器会开始解析CSSOM。HTML解析构建和CSS的解析是相互独立的并不会造成冲突，因此我们通常将css样式放在head中，让浏览器尽早解析css。<br><br>当浏览器接收到 CSS 的原始字节时，会启动一个和处理 HTML 原始字节类似的过程。就是说，原始数据字节被转换成字符，然后标记，然后形成节点，最后形成树结构。<br><br><b>style和内联样式<b><br><br>对这两类样式，浏览器会直接根据样式声明生成CSSOM，因为它们本身就直接含有样式内容。<br><br><b>link<b><br><br>对外联样式，浏览器会首先发送请求，待请求成功，获取外联样式后，浏览器便会解析该外联样式，并生成相应的CSSOM。<br><br><b>CSS阻塞渲染<b><br><br>由于CSSOM负责存储渲染信息，浏览器就必须保证在合成渲染树之前，CSSOM是完备的，这种完备是指所有的CSS（内联、内部和外部）都已经下载完，并解析完，只有CSSOM和DOM的解析完全结束，浏览器才会进入下一步的渲染，这就是传说中的CSS阻塞渲染。<br><br>CSS阻塞渲染意味着，在CSSOM完备前，页面将一直处理白屏状态，这就是为什么样式放在head中，仅仅是为了更快的解析CSS，保证更快的首次渲染。<br><br>需要注意的是，即便你没有给页面任何的样式声明，CSSOM依然会生成，默认生成的CSSOM自带浏览器默认样式（default styles）。<br><br>样式解析生成的CSSOM便含有渲染信息，这些信息会与DOM一起，生成渲染树Render-Tree。<br><br><b>3.Script标签的处理<b><br><br>渲染过程中，如果遇到 <script>就停止渲染，执行 JS 代码。因为浏览器渲染和 JS 执行共用一个线程，而且这里必须是单线程操作，多线程会产生渲染 DOM 冲突。JavaScript的加载、解析与执行会阻塞DOM的构建，也就是说，在构建DOM时，HTML解析器若遇到了JavaScript，那么它会暂停构建DOM，将控制权移交给JavaScript引擎，等JavaScript引擎运行完毕，浏览器再从中断的地方恢复DOM构建。也就是说，如果你想首屏渲染的越快，就越不应该在首屏就加载 JS 文件，这也是都建议将 script 标签放在 body 标签底部的原因。当然在当下，并不是说 script 标签必须放在底部，因为你可以给 script 标签添加 defer 或者 async 属性。<br/><br><b>JS文件不只是阻塞DOM的构建，它会导致CSSOM也阻塞DOM的构建。<b/><br/><br>原本DOM和CSSOM的构建是互不影响，井水不犯河水，但是一旦引入了JavaScript，CSSOM也开始阻塞DOM的构建，只有CSSOM构建完毕后，DOM再恢复DOM构建。这是因为JavaScript不只是可以改DOM，它还可以更改样式，也就是它可以更改CSSOM。因为不完整的CSSOM是无法使用的，如果JavaScript想访问CSSOM并更改它，那么在执行JavaScript时，必须要能拿到完整的CSSOM。所以就导致了一个现象，如果浏览器尚未完成CSSOM的下载和构建，而我们却想在此时运行脚本，那么浏览器将延迟脚本执行和DOM构建，直至其完成CSSOM的下载和构建。也就是说，在这种情况下，浏览器会先下载和构建CSSOM，然后再执行JavaScript，最后在继续构建DOM。<br/><br><b>4.渲染树<b/><br>当DOM和CSSOM构建完成，它们一个存储了节点信息，一个存储了节点渲染信息，都不能直接用来渲染，为此浏览器会将两者结合，生成渲染树（Render-Tree），这棵树就包含了页面所有可见元素及其渲染信息。<br/><br>生成渲染树，浏览器做了这些工作：</p>
<ul>
<li>从DOM的根节点开始，遍历每个可视节点：script、link、meta都属于不可视节点，另外，display: none的节点也属于不可视节点</li>
<li>从CSSOM中搜索可视节点的样式</li>
<li>计算这些样式，将计算值应用到可视节点上<br>渲染树生成后，还是没有办法渲染到屏幕上，渲染到屏幕需要得到各个节点的位置信息，这就需要布局（Layout）的处理了。<br/><br><b>5.布局<b/><br>当浏览器生成渲染树以后，就会根据渲染树来进行布局（也可以叫做回流）。这一阶段浏览器要做的事情是要弄清楚各个节点在页面中的确切位置和大小。通常这一行为也被称为“自动重排”。<br/><br>布局流程的输出是一个“盒模型”，它会精确地捕获每个元素在视口内的确切位置和尺寸，所有相对测量值都将转换为屏幕上的绝对像素。<br/><br>布局使用流模型的Layout算法。所谓流模型，即是指Layout的过程只需进行一遍即可完成，后出现在流中的元素不会影响前出现在流中的元素，Layout过程只需从左至右从上至下一遍完成即可。<br/><br>但实际实现中，流模型会有例外。Layout是一个递归的过程，每个节点都负责自己及其子节点的Layout。Layout结果是相对父节点的坐标和尺寸。其过程可以简述为：<br/></li>
<li>父节点确定自己的宽度</li>
<li>父节点完成子节点放置，确定其相对坐标</li>
<li>节点确定自己的宽度和高度</li>
<li>父节点根据所有的子节点高度计算自己的高度<br><b>6.渲染<b/><br>此时renderTree已经构建完毕，不过浏览器渲染树引擎并不直接使用渲染树进行绘制，为了方便处理定位（裁剪），溢出滚动（页内滚动），CSS转换/不透明/动画/滤镜，蒙版或反射，Z （Z排序）等，浏览器需要生成另外一棵树 - 层树。因此绘制过程如下：<br/></li>
<li>获取 DOM 并将其分割为多个层(RenderLayer)</li>
<li>将每个层栅格化，并独立的绘制进位图中</li>
<li>将这些位图作为纹理上传至 GPU</li>
<li>复合多个层来生成最终的屏幕图像(终极layer)。<h3 id="五、浏览器显示优化"><a href="#五、浏览器显示优化" class="headerlink" title="五、浏览器显示优化"></a>五、浏览器显示优化</h3><h4 id="1-相关定义"><a href="#1-相关定义" class="headerlink" title="1.相关定义"></a>1.相关定义</h4></li>
<li>重绘（Repaint）：当我们对 DOM 的修改导致了样式的变化、却并未影响其几何属性（比如修改了颜色或背景色）时，浏览器不需重新计算元素的几何属性、直接为该元素绘制新的样式（跳过了上图所示的回流环节）。</li>
<li>回流（Reflow）：当我们对 DOM 的修改引发了 DOM 几何尺寸的变化（比如修改元素的宽、高或隐藏元素等）时，浏览器需要重新计算元素的几何属性（其他元素的几何属性和位置也会因此受到影响），然后再将计算的结果绘制出来。这个过程就是回流（也叫重排）<br/><ul>
<li>常见引起回流属性和方法<br/><br>任何会改变元素几何信息(元素的位置和尺寸大小)的操作，都会触发回流<br/><ul>
<li>添加或者删除可见的DOM元素；</li>
<li>元素尺寸改变——边距、填充、边框、宽度和高度</li>
<li>内容变化，比如用户在input框中输入文字</li>
<li>浏览器窗口尺寸改变——resize事件发生时</li>
<li>计算 offsetWidth 和 offsetHeight 属性</li>
<li>设置 style 属性的值</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>我们知道，当网页生成的时候，至少会渲染一次。在用户访问的过程中，还会不断重新渲染。重新渲染会重复回流+重绘或者只有重绘。回流必定会发生重绘，重绘不一定会引发回流。重绘和回流会在我们设置节点样式时频繁出现，同时也会很大程度上影响性能。回流所需的成本比重绘高的多，改变父节点里的子节点很可能会导致父节点的一系列回流。</p>
<ul>
<li>首屏时间——当浏览器显示第一屏页面所消耗的时间，在国内的网络条件下，通常一个网站，如果“首屏时间”在2秒以内是比较优秀的，5秒以内用户可以接受，10秒以上就不可容忍了。</li>
<li>白屏时间——指浏览器开始显示内容的时间。但是在传统的采集方式里，是在HTML的头部标签结尾里记录时间戳，来计算白屏时间。在这个时刻，浏览器开始解析身体标签内的内容。而现代浏览器不会等待CSS树（所有CSS文件下载和解析完成）和DOM树（整个身体标签解析完成）构建完成才开始绘制，而是马上开始显示中间结果。所以经常在低网速的环境中，观察到页面由上至下缓慢显示完，或者先显示文本内容后再重绘成带有格式的页面内容。<h4 id="2-优化办法"><a href="#2-优化办法" class="headerlink" title="2.优化办法"></a>2.优化办法</h4>1、减少资源请求的次数和压缩数据内容。 因为资源的请求是一个复杂的过程。网速相同的条件下，下载一个100KB的图片比下载两个50KB的图片要快。所以，请减少HTTP请求。<br/><ul>
<li>进行资源打包，将需要多次请求的资源进行打包减少资源请求次数，如webpack等。</li>
<li>使用雪碧图，可以避免因不同图片引起的多次资源下载<br>2、高效合理的css选择符可以减轻浏览器的解析负担。<br/></li>
<li>因为css是逆向解析的所以应当避免多层嵌套。</li>
<li>避免使用通配规则。如 *{} 计算次数惊人！只对需要用到的元素进行选择</li>
<li>不要去用标签限定ID或者类选择符。如：ul#nav,应该简化为#nav</li>
<li>尽量少的去使用后代选择器，降低选择器的权重值。后代选择器的开销是最高的，尽量将选择器的深度降到最低，最高不要超过三层，更多的使用类来关联每一个标签元素。</li>
<li>考虑继承。了解哪些属性是可以通过继承而来的，然后避免对这些属性重复指定规则</li>
</ul>
</li>
</ul>
<p>3、从js层面谈页面优化</p>
<pre><code>* 解决渲染阻塞&lt;br/&gt;
如果在解析HTML标记时，浏览器遇到了JavaScript，解析会停止。只有在该脚本执行完毕后，HTML渲染才会继续进行。所以这阻塞了页面的渲染。&lt;br/&gt;
解决方法：在标签中使用 async或defer特性&lt;br/&gt;
* 减少对DOM的操作
对DOM操作的代价是高昂的，这在网页应用中的通常是一个性能瓶颈。&lt;br/&gt;
解决办法：修改和访问DOM元素会造成页面的Repaint和Reflow，循环对DOM操作更是罪恶的行为。所以请合理的使用JavaScript变量储存内容，考虑大量DOM元素中循环的性能开销，在循环结束时一次性写入。&lt;br/&gt;
减少对DOM元素的查询和修改，查询时可将其赋值给局部变量。&lt;br/&gt;
* 使用JSON格式来进行数据交换
JSON是一种轻量级的数据交换格式，采用完全独立于语言的文本格式，是理想的数据交换格式。同时，JSON是 JavaScript原生格式，这意味着在 JavaScript 中处理 JSON数据不需要任何特殊的 API 或工具包。&lt;br/&gt;
* 让需要经常改动的节点脱离文档流
因为重绘有时确实不可避免，所以只能尽可能限制重绘的影响范围。&lt;br/&gt;
</code></pre></script></b></b></b></b></b></b></b></b></p>
            <!--[if lt IE 9]><script>document.createElement('audio');</script><![endif]-->
            <audio id="audio" loop="1" preload="auto" controls="controls" data-autoplay="false">
                <source type="audio/mpeg" src="">
            </audio>
            
                <ul id="audio-list" style="display:none">
                    
                        <li title="0" data-url="http://link.hhtjim.com/163/5146554.mp3"></li>
                    
                        <li title="1" data-url="http://link.hhtjim.com/qq/001faIUs4M2zna.mp3"></li>
                    
                </ul>
            
        </div>
        
    <div id="gitalk-container" class="comment link" data-ae="false" data-ci="" data-cs="" data-r="" data-o="" data-a="" data-d="false">查看评论</div>


    </div>
    
</div>


    </div>
</div>
</body>
<script src="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>
<script src="//lib.baomitu.com/jquery/1.8.3/jquery.min.js"></script>
<script src="/js/plugin.js"></script>
<script src="/js/diaspora.js"></script>
<link rel="stylesheet" href="/photoswipe/photoswipe.css">
<link rel="stylesheet" href="/photoswipe/default-skin/default-skin.css">
<script src="/photoswipe/photoswipe.min.js"></script>
<script src="/photoswipe/photoswipe-ui-default.min.js"></script>

<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">
    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>
    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">
        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>
        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">
            <div class="pswp__top-bar">
                <!--  Controls are self-explanatory. Order can be changed. -->
                <div class="pswp__counter"></div>
                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
                <button class="pswp__button pswp__button--share" title="Share"></button>
                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>
            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>
            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>
            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>
            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>
        </div>
    </div>
</div>




</html>