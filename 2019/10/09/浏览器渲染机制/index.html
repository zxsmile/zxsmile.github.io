
<!DOCTYPE html>
<html lang="" class="loading">
<head><meta name="generator" content="Hexo 3.8.0">
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Hexo</title>

    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="google" content="notranslate">
    <meta name="keywords" content="Fechin,"> 
    
    <meta name="author" content="zxSmile"> 
    <link rel="alternative" href="atom.xml" title="Hexo" type="application/atom+xml"> 
    <link rel="icon" href="/img/favicon.png"> 
    <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">
    <link rel="stylesheet" href="/css/diaspora.css">
</head>
</html>
<body class="loading">
    <div id="loader"></div>
    <div id="single">
    <div id="top" style="display: block;">
    <div class="bar" style="width: 0;"></div>
    <a class="icon-home image-icon" href="javascript:;"></a>
    <div title="播放/暂停" class="icon-play"></div>
    <h3 class="subtitle">浏览器渲染机制</h3>
    <div class="social">
        <!--<div class="like-icon">-->
            <!--<a href="javascript:;" class="likeThis active"><span class="icon-like"></span><span class="count">76</span></a>-->
        <!--</div>-->
        <div>
            <div class="share">
                <a title="获取二维码" class="icon-scan" href="javascript:;"></a>
            </div>
            <div id="qr"></div>
        </div>
    </div>
    <div class="scrollbar"></div>
</div>
    <div class="section">
        <div class="article">
    <div class="main">
        <h1 class="title">浏览器渲染机制</h1>
        <div class="stuff">
            <span>十月 09, 2019</span>
            

        </div>
        <div class="content markdown">
            <h3 id="一、浏览器的主要组成"><a href="#一、浏览器的主要组成" class="headerlink" title="一、浏览器的主要组成"></a>一、浏览器的主要组成</h3><ul>
<li><p>用户界面－包括地址栏、后退/前进按钮、书签目录等，也就是你所看到的除了用来显示你所请求页面的主窗口之外的其他部分</p>
</li>
<li><p>浏览器引擎－用来查询及操作渲染引擎的接口</p>
</li>
<li><p>渲染引擎－用来显示请求的内容，例如，如果请求内容为html，它负责解析html及css，并将解析后的结果显示出来</p>
</li>
<li><p>网络－用来完成网络调用，例如http请求，它具有平台无关的接口，可以在不同平台上工作</p>
</li>
<li><p>UI 后端－用来绘制类似组合选择框及对话框等基本组件，具有不特定于某个平台的通用接口，底层使用操作系统的用户接口</p>
</li>
<li><p>JS解释器（又称JavaScript引擎）－用来解释执行JS代码</p>
</li>
<li><p>数据存储－属于持久层，浏览器需要在硬盘中保存类似cookie的各种数据，HTML5定义了web database技术，这是一种轻量级完整的客户端存储技术</p>
<h3 id="二、浏览器主要的功能"><a href="#二、浏览器主要的功能" class="headerlink" title="二、浏览器主要的功能"></a>二、浏览器主要的功能</h3><p>浏览器的主要功能是将用户选择的web资源呈现出来，它需要从服务器请求资源，并将其显示在浏览器窗口中，资源的格式通常是HTML，也包括PDF、image及其他格式。用户用URI来指定所请求资源的位置。</p>
<h3 id="三、从输入-URL-到页面加载完成，发生了什么？"><a href="#三、从输入-URL-到页面加载完成，发生了什么？" class="headerlink" title="三、从输入 URL 到页面加载完成，发生了什么？"></a>三、从输入 URL 到页面加载完成，发生了什么？</h3><p>DNS 解析  <br><br> |      <br><br>TCP 连接   <br><br> |<br><br>HTTP 请求抛出<br><br> |<br><br>服务端处理请求，HTTP 响应返回<br><br> |<br><br>浏览器拿到响应数据，解析响应内容，把解析的结果展示给用户<br></p>
<h3 id="四、浏览器渲染机制"><a href="#四、浏览器渲染机制" class="headerlink" title="四、浏览器渲染机制"></a>四、浏览器渲染机制</h3><p>浏览器渲染的处理就是最后一步，浏览器拿到响应数据，解析响应内容，把解析的结果展示给用户。<br><br><b>浏览器内核</b><br><br>浏览器的内核是指支持浏览器运行的最核心的程序，负责将页面转变为可视化的图像结果,分为两个部分，一是渲染引擎，另一个是JS引擎。</p>
</li>
<li>渲染引擎，负责对网页语法的解释（如HTML、JavaScript）并渲染网页。渲染引擎决定了浏览器如何显示网页的内容以及页面的格式信息。</li>
<li>JavaScript引擎的主要作用是，读取网页中的JavaScript代码，对其处理后运行。<br><b>关键渲染路径</b><br><br>关键渲染路径是指浏览器从最初接受到请求的HTML、CSS、javascript等资源，然后解析、构建树、渲染布局、绘制，最后呈现给客户能看到的界面这整个过程。用户看到页面实际上可以分为两个阶段：页面内容加载完成和页面资源完成，分别对应于DOMContentLoaded和Load。<br><br>DOMContentLoaded:当 DOMContentLoaded 事件触发时，仅当DOM加载完成，不包括样式表，图片。<br><br>Load:当 onload 事件触发时，页面上所有的DOM，样式表，脚本，图片都已经加载完成了。（渲染完毕了）<br><br>所以，顺序是：DOMContentLoaded -&gt; load<br><br>整个关键渲染路径包括以下几个步骤：<ul>
<li>解析HTML，生成DOM树（DOM）</li>
<li>解析CSS，生成CSSOM树（CSSOM）</li>
<li>将DOM和CSSOM合并，生成渲染树（Render-Tree）</li>
<li>计算渲染树的布局（Layout）</li>
<li>将布局渲染到屏幕上（Paint）<br>以上步骤没有包括脚本JS的处理，并不是脚本处理不在关键渲染路径中，而是因为JS的处理会对1、2产生影响，下面会介绍。<br>1.DOM的生成<br><br>首先我们知道，数据在网络传输中是以“数据包”的形式通过互联网发送，而数据包以字节为单位。<br><br>当你编写一些 HTML、CSS 和 JS，并试图在浏览器中打开 HTML 文件时，浏览器会从你的硬盘（或网络）中读取 HTML 的原始字节。浏览器读取的是原始数据字节，而不是你编写的代码的实际字符。但是，它用这些数据什么都做不了。数据的原始字节必须转换为它所理解的形式。<br><br>浏览器对象需要处理的是文档对象模型（DOM）对象。所以要将构建一个DOM对象：<br></li>
<li>首先，根据文件的指定编码（例如 UTF-8）将原始数据字节转换为字符,也就是我们写的代码。</li>
<li>将字符转换成Token，例如： <html>、 <body>等。Token中会标识出当前Token是“开始标签”或是“结束标签”亦或是“文本”等信息。</body></html></li>
<li>生成节点对象并构建DOM<br>事实上，构建DOM的过程中，不是等所有Token都转换完成后再去生成节点对象，而是一边生成Token一边消耗Token来生成节点对象。换句话说，每个Token被生成后，会立刻消耗这个Token创建出节点对象。<b>注意：带有结束标签标识的Token不会创建节点对象。<b><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;Web page parsing&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;h1&gt;Web page parsing&lt;/h1&gt;</span><br><span class="line">        &lt;p&gt;This is an example Web page.&lt;/p&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
</b></b></li>
</ul>
</li>
</ul>
<p>上面这段HTML会解析成这样：<br><br><img src="/2019/10/09/浏览器渲染机制/img1.png" alt=""><br>解析完HTML，单纯使用DOM，浏览器并不知道如何渲染这棵树，DOM只是存储了元素的关系，并没有任何渲染信息，如宽高、颜色、背景、定位等。存储这些信息，就需要CSSOM了。<br><br><b>2.CSSOM生成</b><br><br>在HTML的解析过程中，会碰到style、link和内联样式，这时，浏览器会开始解析CSSOM。HTML解析构建和CSS的解析是相互独立的并不会造成冲突，<b>因此css不会阻塞DOM树的解析。</b><br><br>当浏览器接收到 CSS 的原始字节时，会启动一个和处理 HTML 原始字节类似的过程。就是说，原始数据字节被转换成字符，然后标记，然后形成节点，最后形成树结构。<br><br><b>style和内联样式</b><br><br>对这两类样式，浏览器会直接根据样式声明生成CSSOM，因为它们本身就直接含有样式内容。<br><br><b>link</b><br><br>对外联样式，浏览器会首先发送请求，待请求成功，获取外联样式后，浏览器便会解析该外联样式，并生成相应的CSSOM。<br><br><b>CSS阻塞DOM树（render树）的渲染</b><br><br>由于CSSOM负责存储渲染信息，浏览器就必须保证在合成渲染树之前，CSSOM是完备的，这种完备是指所有的CSS（内联、内部和外部）都已经下载完，并解析完，只有CSSOM和DOM的解析完全结束，浏览器才会进入下一步的渲染，这就是传说中的CSS阻塞渲染。<br><br>CSS阻塞渲染意味着，在CSSOM完备前，页面将一直处理白屏状态，这就是为什么样式放在head中，仅仅是为了更快的解析CSS，保证更快的首次渲染。<br><br>需要注意的是，即便你没有给页面任何的样式声明，CSSOM依然会生成，默认生成的CSSOM自带浏览器默认样式（default styles）。<br><br>样式解析生成的CSSOM便含有渲染信息，这些信息会与DOM一起，生成渲染树Render-Tree。<br></p>
<p><b>css加载会阻塞后面js语句的执行</b><br><br>这是因为JavaScript不只是可以改DOM，它还可以更改样式，也就是它可以更改CSSOM。因为不完整的CSSOM是无法使用的，如果JavaScript想访问CSSOM并更改它，那么在执行JavaScript时，必须要能拿到完整的CSSOM。所以就导致了一个现象，如果浏览器尚未完成CSSOM的下载和构建，而我们却想在此时运行脚本，那么浏览器将延迟脚本执行。</p>
<p><font color="red">Css 的加载会阻塞 Dom 的渲染，并不会阻塞 Dom 的解析，也会阻塞 JavaScript 的执行。</font><br></p>
<p><b>3.Script标签的处理</b><br><br>渲染过程中，如果遇到script标签就停止渲染，执行 JS 代码。因为浏览器渲染和 JS 执行共用一个线程，而且这里必须是单线程操作，多线程会产生渲染 DOM 冲突。JavaScript的加载、解析与执行会阻塞DOM的构建，也就是说，在构建DOM时，HTML解析器若遇到了JavaScript，那么它会暂停构建DOM，将控制权移交给JavaScript引擎，等JavaScript引擎运行完毕，浏览器再从中断的地方恢复DOM构建。也就是说，如果你想首屏渲染的越快，就越不应该在首屏就加载 JS 文件，这也是都建议将 script 标签放在 body 标签底部的原因。当然在当下，并不是说 script 标签必须放在底部，因为你可以给 script 标签添加 defer 或者 async 属性。<br><br><b>async 和 defer</b><br><br>async 和 defer 他们对于内联脚本无作用（即没有 src 属性的脚本）<br><br>async该布尔属性指示浏览器是否在允许的情况下异步执行该脚本。async 与 defer 的区别在于，如果已经加载好，就会开始执行——无论此刻是 HTML 解析阶段还是 DOMContentLoaded 触发之后。需要注意的是，这种方式加载的 JavaScript 依然会阻塞 load 事件。换句话说，async-script 可能在 DOMContentLoaded 触发之前或之后执行，但一定在 load 触发之前执行。并且多个 async-script 的执行顺序是不确定的。<br><br>defer 属性表示延迟执行引入的 JavaScript，即这段 JavaScript 加载时 HTML 并未停止解析，这两个过程是并行的。整个 document 解析完毕且 defer-script 也加载完成之后（这两件事情的顺序无关），会执行所有由 defer-script 加载的 JavaScript 代码，然后触发 DOMContentLoaded 事件。<br><br>defer 与相比普通 script，有两点区别：载入 JavaScript 文件时不阻塞 HTML 的解析，执行阶段被放到 HTML 标签解析完成之后。<br><br><b>预加载文件preload 和 prefetch</b><br><br>使用 preload 可以对当前页面所需的脚本、样式等资源进行预加载，而无需等到解析到 script 和 link 标签时才进行加载。这一机制使得资源可以更早的得到加载并可用，且更不易阻塞页面的初步渲染，进而提升性能<br><br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;head&gt;</span><br><span class="line">   &lt;meta charset=<span class="string">"utf-8"</span>/&gt;</span><br><span class="line">   &lt;title&gt;preload example&lt;/title&gt;</span><br><span class="line">   &lt;!-- 对 style.css 和 index.js 进行预加载 --&gt;</span><br><span class="line">   &lt;link rel=<span class="string">"preload"</span> href=<span class="string">"style.css"</span> <span class="keyword">as</span>=<span class="string">"style"</span>/&gt;</span><br><span class="line">   &lt;link rel=<span class="string">"preload"</span> href=<span class="string">"index.js"</span> <span class="keyword">as</span>=<span class="string">"script"</span>/&gt;</span><br><span class="line">&lt;/head&gt;</span><br></pre></td></tr></table></figure></p>
<p>prerender 是一个重量级的选项，它可以让浏览器提前加载指定页面的所有资源。prerender 就像是在后台打开了一个隐藏的 tab，会下载所有的资源、创建DOM、渲染页面、执行js等等。如果用户进入指定的链接，隐藏的这个页面就会立马进入用户的视线。但是要注意，一定要在十分确定用户会点击某个链接时才使用该特性，否则客户端会无端的下载很多资源和渲染这个页面。<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;link rel=<span class="string">"prerender"</span> href=<span class="string">"/thenextpage.html"</span> /&gt;</span><br></pre></td></tr></table></figure></p>
<p><b>JS文件不只是阻塞DOM的构建，它会导致CSSOM也阻塞DOM的构建。</b><br><br>原本DOM和CSSOM的构建是互不影响，井水不犯河水，但是一旦引入了JavaScript，CSSOM也开始阻塞DOM的构建，只有CSSOM构建完毕后，DOM再恢复DOM构建。这是因为JavaScript不只是可以改DOM，它还可以更改样式，也就是它可以更改CSSOM。因为不完整的CSSOM是无法使用的，如果JavaScript想访问CSSOM并更改它，那么在执行JavaScript时，必须要能拿到完整的CSSOM。所以就导致了一个现象，如果浏览器尚未完成CSSOM的下载和构建，而我们却想在此时运行脚本，那么浏览器将延迟脚本执行和DOM构建，直至其完成CSSOM的下载和构建。也就是说，在这种情况下，浏览器会先下载和构建CSSOM，然后再执行JavaScript，最后在继续构建DOM。<br></p>
<p><font color="red">JavaScript 的加载会阻塞 Dom 的解析和渲染，并且也会阻塞 css 的解析和渲染。</font><br></p>
<p><font color="red">img的加载不会阻塞html的解析，但img加载后并不渲染，它需要等待Render Tree生成完后才和Render Tree一起渲染出来。未下载完的图片需等下载完后才渲染。</font><br><br><b>4.渲染树</b><br><br>当DOM和CSSOM构建完成，它们一个存储了节点信息，一个存储了节点渲染信息，都不能直接用来渲染，为此浏览器会将两者结合，生成渲染树（Render-Tree），这棵树就包含了页面所有可见元素及其渲染信息。<br><br>生成渲染树，浏览器做了这些工作：</p>
<ul>
<li>从DOM的根节点开始，遍历每个可视节点：script、link、meta都属于不可视节点，另外，display: none的节点也属于不可视节点</li>
<li>从CSSOM中搜索可视节点的样式</li>
<li>计算这些样式，将计算值应用到可视节点上<br>渲染树生成后，还是没有办法渲染到屏幕上，渲染到屏幕需要得到各个节点的位置信息，这就需要布局（Layout）的处理了。<br></li>
</ul>
<p><b>5.布局(layout)</b><br><br>当浏览器生成渲染树以后，就会根据渲染树来进行布局（也可以叫做回流）。这一阶段浏览器要做的事情是要弄清楚各个节点在页面中的确切位置和大小。通常这一行为也被称为“自动重排”。<br><br>布局流程的输出是一个“盒模型”，它会精确地捕获每个元素在视口内的确切位置和尺寸，所有相对测量值都将转换为屏幕上的绝对像素。<br><br>布局使用流模型的Layout算法。所谓流模型，即是指Layout的过程只需进行一遍即可完成，后出现在流中的元素不会影响前出现在流中的元素，Layout过程只需从左至右从上至下一遍完成即可。<br><br>但实际实现中，流模型会有例外。Layout是一个递归的过程，每个节点都负责自己及其子节点的Layout。Layout结果是相对父节点的坐标和尺寸。其过程可以简述为：<br></p>
<ul>
<li>父节点确定自己的宽度</li>
<li>父节点完成子节点放置，确定其相对坐标</li>
<li>节点确定自己的宽度和高度</li>
<li>父节点根据所有的子节点高度计算自己的高度</li>
</ul>
<p><b>6.渲染(绘制 painting)</b><br><br>此时renderTree已经构建完毕，不过浏览器渲染树引擎并不直接使用渲染树进行绘制，为了方便处理定位（裁剪），溢出滚动（页内滚动），CSS转换/不透明/动画/滤镜，蒙版或反射，Z （Z排序）等，浏览器需要生成另外一棵树 - 层树。因此绘制过程如下：<br></p>
<ul>
<li>获取 DOM 并将其分割为多个层(RenderLayer)</li>
<li>将每个层栅格化，并独立的绘制进位图中</li>
<li>将这些位图作为纹理上传至 GPU，在GPU中进行合成。<br><b>7.合成(Composite)</b><br><br>对页面中 DOM 元素的绘制是在多个层上进行的。在每个层上完成绘制过程之后，浏览器会将所有层按照合理的顺序合并成一个图层，然后显示在屏幕上。<br><br><a href="https://segmentfault.com/a/1190000008015671" target="_blank" rel="noopener">https://segmentfault.com/a/1190000008015671</a><h3 id="五、浏览器显示优化"><a href="#五、浏览器显示优化" class="headerlink" title="五、浏览器显示优化"></a>五、浏览器显示优化</h3><h4 id="1-相关定义"><a href="#1-相关定义" class="headerlink" title="1.相关定义"></a>1.相关定义</h4></li>
<li>重绘（Repaint）：repaint 就是在<font color="red">不影响排版的情况下对这个元素重新绘制的过程。例如改变一个元素的背景颜色、字体颜色等。</font></li>
<li>回流（Reflow）：当 render tree 中的一部分（或全部）因为元素的规模尺寸，布局，隐藏等改变而需要重新构建。这就称为回流（其实我觉得叫重新布局更简单明了些）。每个页面至少需要一次回流，就是在页面第一次加载的时候。（也叫重排）<br><br><font color="red">回流必将引起重绘，而重绘不一定会引起回流</font><br></li>
<li>触发 repaint、reflow<br><pre><code>* 添加、删除元素（回流+重绘）
* 隐藏元素，display:none(回流+重绘)，visibility:hidden(只重绘，不回流)
* 移动元素，比如改变 top、left（jquery 的 animate 方法就是改变 top、left 不一定会影响回流），或者移动元素到另外 1 个父元素中。(重绘+回流)
* 对 style 的操作（对不同的属性操作，影响不一样）（color、background-color）=&gt;(重绘) (padding、margin)=&gt;(回流)
* 浏览器大小改变resize、font-size（重绘+回流）
* transform/opacity （不会触发生重绘、回流）
* 最复杂的一种：获取某些属性，引发回流 很多浏览器会对回流做优化，他会等到足够数量的变化发生，在做一次批处理回流。 但是除了 render 树的直接变化。 当获取一些属性时，浏览器为了获得正确的值也会触发回流。
</code></pre>&ensb;&ensb;&ensb;&ensb;1.offsetTop, offsetLeft, offsetWidth, offsetHeight<br><br>&ensb;&ensb;&ensb;&ensb;2.scrollTop/Left/Width/Height<br><br>&ensb;&ensb;&ensb;&ensb;3.clientTop/Left/Width/Height<br><br>&ensb;&ensb;&ensb;&ensb;4.width,height<br><br>&ensb;&ensb;&ensb;&ensb;5.调用了 getComputedStyle(), 或者 IE 的 currentStyle<br></li>
<li>减少重绘和回流<pre><code>* 避免逐项更改样式。最好一次性更改 style 属性，或者将样式列表定义为 class 并一次性更改 class 属性。
* 避免循环操作 DOM。创建一个 documentFragment 或 div，在它上面应用所有 DOM 操作，最后再把它添加到 window.document。
* 避免多次读取 offsetLeft 等属性。无法避免则将它们缓存到变量。
* 将复杂的元素绝对定位或固定定位，使它脱离文档流。否则回流代价十分高
* 不要使用 table 布局，可能很小的一个小改动会造成整个 table 的重新布局
* 动画实现的速度的选择，动画速度越快，回流次数越多，也可以选择使用 requestAnimationFrame
* CSS 选择符从右往左匹配查找，避免 DOM 深度过深
* 使用 visibility 替换 display: none ，因为前者只会引起重绘，后者会引发回流（改变了布局）
* 使用 translate 替代 top
* 把 DOM 离线后修改，比如：先把 DOM 给 display:none (有一次 Reflow)，然后你修改 100 次，然后再把它显示出来
* 使用 flexbox 替代老的布局模型
</code></pre>我们知道，当网页生成的时候，至少会渲染一次。在用户访问的过程中，还会不断重新渲染。重新渲染会重复回流+重绘或者只有重绘。回流必定会发生重绘，重绘不一定会引发回流。重绘和回流会在我们设置节点样式时频繁出现，同时也会很大程度上影响性能。回流所需的成本比重绘高的多，改变父节点里的子节点很可能会导致父节点的一系列回流。</li>
<li>首屏时间——当浏览器显示第一屏页面所消耗的时间，在国内的网络条件下，通常一个网站，如果“首屏时间”在2秒以内是比较优秀的，5秒以内用户可以接受，10秒以上就不可容忍了。</li>
<li>白屏时间——指浏览器开始显示内容的时间。但是在传统的采集方式里，是在HTML的头部标签结尾里记录时间戳，来计算白屏时间。在这个时刻，浏览器开始解析身体标签内的内容。而现代浏览器不会等待CSS树（所有CSS文件下载和解析完成）和DOM树（整个身体标签解析完成）构建完成才开始绘制，而是马上开始显示中间结果。所以经常在低网速的环境中，观察到页面由上至下缓慢显示完，或者先显示文本内容后再重绘成带有格式的页面内容。<h4 id="2-优化办法"><a href="#2-优化办法" class="headerlink" title="2.优化办法"></a>2.优化办法</h4>1、减少资源请求的次数和压缩数据内容。 因为资源的请求是一个复杂的过程。网速相同的条件下，下载一个100KB的图片比下载两个50KB的图片要快。所以，请减少HTTP请求。<br><ul>
<li>进行资源打包，将需要多次请求的资源进行打包减少资源请求次数，如webpack等。</li>
<li>使用雪碧图，可以避免因不同图片引起的多次资源下载<br>2、高效合理的css选择符可以减轻浏览器的解析负担。</li>
<li>因为css是逆向解析的所以应当避免多层嵌套。</li>
<li>避免使用通配规则。如 *{} 计算次数惊人！只对需要用到的元素进行选择</li>
<li>不要去用标签限定ID或者类选择符。如：ul#nav,应该简化为#nav</li>
<li>尽量少的去使用后代选择器，降低选择器的权重值。后代选择器的开销是最高的，尽量将选择器的深度降到最低，最高不要超过三层，更多的使用类来关联每一个标签元素。</li>
<li>考虑继承。了解哪些属性是可以通过继承而来的，然后避免对这些属性重复指定规则</li>
</ul>
</li>
</ul>
<p>3、从js层面谈页面优化</p>
<pre><code>* 解决渲染阻塞&lt;br/&gt;
</code></pre><p>&ensb;&ensb;&ensb;&ensb;如果在解析HTML标记时，浏览器遇到了JavaScript，解析会停止。只有在该脚本执行完毕后，HTML渲染才会继续进行。所以这阻塞了页面的渲染。<br><br>&ensb;&ensb;&ensb;&ensb;解决方法：在标签中使用 async或defer特性<br></p>
<pre><code>* 减少对DOM的操作
</code></pre><p>&ensb;&ensb;&ensb;&ensb;对DOM操作的代价是高昂的，这在网页应用中的通常是一个性能瓶颈。<br><br>&ensb;&ensb;&ensb;&ensb;解决办法：修改和访问DOM元素会造成页面的Repaint和Reflow，循环对DOM操作更是罪恶的行为。所以请合理的使用JavaScript变量储存内容，考虑大量DOM元素中循环的性能开销，在循环结束时一次性写入。<br><br>&ensb;&ensb;&ensb;&ensb;减少对DOM元素的查询和修改，查询时可将其赋值给局部变量。<br></p>
<pre><code>* 使用JSON格式来进行数据交换
</code></pre><p>&ensb;&ensb;&ensb;&ensb;JSON是一种轻量级的数据交换格式，采用完全独立于语言的文本格式，是理想的数据交换格式。同时，JSON是 JavaScript原生格式，这意味着在 JavaScript 中处理 JSON数据不需要任何特殊的 API 或工具包。<br></p>
<pre><code>* 让需要经常改动的节点脱离文档流
</code></pre><p>&ensb;&ensb;&ensb;&ensb;因为重绘有时确实不可避免，所以只能尽可能限制重绘的影响范围。<br></p>

            <!--[if lt IE 9]><script>document.createElement('audio');</script><![endif]-->
            <audio id="audio" loop="1" preload="auto" controls="controls" data-autoplay="false">
                <source type="audio/mpeg" src="">
            </audio>
            
                <ul id="audio-list" style="display:none">
                    
                        <li title="0" data-url="http://link.hhtjim.com/163/5146554.mp3"></li>
                    
                        <li title="1" data-url="http://link.hhtjim.com/qq/001faIUs4M2zna.mp3"></li>
                    
                </ul>
            
        </div>
        
    <div id="gitalk-container" class="comment link" data-ae="false" data-ci="" data-cs="" data-r="" data-o="" data-a="" data-d="false">查看评论</div>


    </div>
    
</div>


    </div>
</div>
</body>
<script src="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>
<script src="//lib.baomitu.com/jquery/1.8.3/jquery.min.js"></script>
<script src="/js/plugin.js"></script>
<script src="/js/diaspora.js"></script>
<link rel="stylesheet" href="/photoswipe/photoswipe.css">
<link rel="stylesheet" href="/photoswipe/default-skin/default-skin.css">
<script src="/photoswipe/photoswipe.min.js"></script>
<script src="/photoswipe/photoswipe-ui-default.min.js"></script>

<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">
    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>
    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">
        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>
        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">
            <div class="pswp__top-bar">
                <!--  Controls are self-explanatory. Order can be changed. -->
                <div class="pswp__counter"></div>
                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
                <button class="pswp__button pswp__button--share" title="Share"></button>
                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>
            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>
            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>
            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>
            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>
        </div>
    </div>
</div>




</html>